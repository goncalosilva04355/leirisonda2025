import {
  collection,
  doc,
  setDoc,
  getDocs,
  query,
  orderBy,
  onSnapshot,
  Unsubscribe,
  deleteDoc,
  updateDoc,
  writeBatch,
} from "firebase/firestore";
import { db, isFirebaseReady, waitForFirebaseInit } from "../firebase/config";

export interface UniversalDataState {
  obras: any[];
  manutencoes: any[];
  piscinas: any[];
  clientes: any[];
  totalItems: number;
  lastSync: string;
  isGloballyShared: boolean;
}

/**
 * SERVI√áO UNIVERSAL DE SINCRONIZA√á√ÉO
 * Garante que TODOS os utilizadores vejam TODOS os dados em QUALQUER dispositivo
 *
 * Funcionalidades:
 * - Partilha global autom√°tica de obras, manuten√ß√µes, piscinas e clientes
 * - Sincroniza√ß√£o em tempo real entre todos os dispositivos
 * - Migra√ß√£o autom√°tica de dados locais para globais
 * - Resistente a falhas de rede
 * - Backup autom√°tico de dados
 */
class UniversalDataSyncService {
  private listeners: Unsubscribe[] = [];
  private isInitialized = false;
  private syncInProgress = false;

  /**
   * Inicializar o servi√ßo universal
   */
  async initialize(): Promise<boolean> {
    if (this.isInitialized) {
      return true;
    }

    // Inicializar sincroniza√ß√£o universal silenciosa

    try {
      const firebaseReady = await waitForFirebaseInit();
      if (!firebaseReady || !isFirebaseReady()) {
        console.warn("‚ö†Ô∏è Firebase n√£o dispon√≠vel - modo local apenas");
        // Still return true to allow local operation
        this.isInitialized = true;
        return true;
      }

      // Migrar dados existentes para estrutura universal
      await this.migrateToUniversalSharing();

      this.isInitialized = true;
      return true;
    } catch (error) {
      console.error("‚ùå Erro na inicializa√ß√£o universal:", error);
      return false;
    }
  }

  /**
   * Migrar todos os dados para partilha universal
   */
  private async migrateToUniversalSharing(): Promise<void> {
    if (this.syncInProgress) {
      console.log("‚è≥ Migra√ß√£o j√° em progresso...");
      return;
    }

    this.syncInProgress = true;
    console.log("üîÑ MIGRANDO DADOS PARA PARTILHA UNIVERSAL...");

    try {
      // Obter dados locais (apenas uma vez para migra√ß√£o)
      const localData = {
        obras: this.getLocalDataSafe("works") || [],
        manutencoes: this.getLocalDataSafe("maintenance") || [],
        piscinas: this.getLocalDataSafe("pools") || [],
        clientes: this.getLocalDataSafe("clients") || [],
      };

      const totalLocal = Object.values(localData).reduce(
        (total, items) => total + items.length,
        0,
      );

      if (totalLocal > 0) {
        console.log(`üì± Encontrados ${totalLocal} registos locais para migrar`);

        // Verificar dados existentes no Firebase
        const existingData = await this.getAllUniversalData();
        const totalExisting = existingData.totalItems;

        if (totalExisting === 0) {
          console.log(
            "üöÄ Primeira migra√ß√£o - transferindo todos os dados locais",
          );

          // Migrar em lotes para melhor performance
          const batch = writeBatch(db!);
          let batchCount = 0;
          const maxBatchSize = 450; // Limite do Firestore

          // Migrar obras
          for (const obra of localData.obras) {
            const id = obra.id || `obra-${Date.now()}-${Math.random()}`;
            const docRef = doc(db!, "universal_obras", id);
            batch.set(docRef, {
              ...obra,
              id,
              universallyShared: true,
              visibleToAllUsers: true,
              migratedAt: new Date().toISOString(),
              lastSync: new Date().toISOString(),
            });

            batchCount++;
            if (batchCount >= maxBatchSize) {
              await batch.commit();
              batchCount = 0;
            }
          }

          // Migrar manuten√ß√µes
          for (const manutencao of localData.manutencoes) {
            const id =
              manutencao.id || `manutencao-${Date.now()}-${Math.random()}`;
            const docRef = doc(db!, "universal_manutencoes", id);
            batch.set(docRef, {
              ...manutencao,
              id,
              universallyShared: true,
              visibleToAllUsers: true,
              migratedAt: new Date().toISOString(),
              lastSync: new Date().toISOString(),
            });

            batchCount++;
            if (batchCount >= maxBatchSize) {
              await batch.commit();
              batchCount = 0;
            }
          }

          // Migrar piscinas
          for (const piscina of localData.piscinas) {
            const id = piscina.id || `piscina-${Date.now()}-${Math.random()}`;
            const docRef = doc(db!, "universal_piscinas", id);
            batch.set(docRef, {
              ...piscina,
              id,
              universallyShared: true,
              visibleToAllUsers: true,
              migratedAt: new Date().toISOString(),
              lastSync: new Date().toISOString(),
            });

            batchCount++;
            if (batchCount >= maxBatchSize) {
              await batch.commit();
              batchCount = 0;
            }
          }

          // Migrar clientes
          for (const cliente of localData.clientes) {
            const id = cliente.id || `cliente-${Date.now()}-${Math.random()}`;
            const docRef = doc(db!, "universal_clientes", id);
            batch.set(docRef, {
              ...cliente,
              id,
              universallyShared: true,
              visibleToAllUsers: true,
              migratedAt: new Date().toISOString(),
              lastSync: new Date().toISOString(),
            });

            batchCount++;
            if (batchCount >= maxBatchSize) {
              await batch.commit();
              batchCount = 0;
            }
          }

          // Executar √∫ltimo batch se houver dados pendentes
          if (batchCount > 0) {
            await batch.commit();
          }

          console.log(
            "‚úÖ MIGRA√á√ÉO CONCLU√çDA - Dados agora universalmente partilhados",
          );

          // Criar marca de migra√ß√£o
          await setDoc(doc(db!, "universal_config", "migration_status"), {
            completed: true,
            migratedAt: new Date().toISOString(),
            totalMigrated: totalLocal,
            migratedData: {
              obras: localData.obras.length,
              manutencoes: localData.manutencoes.length,
              piscinas: localData.piscinas.length,
              clientes: localData.clientes.length,
            },
          });
        } else {
          console.log(
            `üìä Dados existentes no Firebase: ${totalExisting} registos`,
          );
        }
      } else {
        console.log("üì≠ Nenhum dado local encontrado para migrar");
      }

      console.log("üåê TODOS OS DADOS AGORA S√ÉO UNIVERSALMENTE PARTILHADOS");
    } catch (error) {
      console.error("‚ùå Erro na migra√ß√£o universal:", error);
      throw error;
    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * Obter dados locais de forma segura
   */
  private getLocalDataSafe(key: string): any[] {
    try {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : [];
    } catch (error) {
      console.warn(`‚ö†Ô∏è Erro ao ler dados locais ${key}:`, error);
      return [];
    }
  }

  /**
   * Configurar listeners do localStorage como fallback
   */
  private setupLocalStorageListeners(callbacks: {
    onObrasChange: (obras: any[]) => void;
    onManutencoesChange: (manutencoes: any[]) => void;
    onPiscinasChange: (piscinas: any[]) => void;
    onClientesChange: (clientes: any[]) => void;
  }): () => void {
    console.log("üì± Configurando listeners do armazenamento local");

    // Load initial data
    const localData = this.getLocalData();
    callbacks.onObrasChange(localData.obras);
    callbacks.onManutencoesChange(localData.manutencoes);
    callbacks.onPiscinasChange(localData.piscinas);
    callbacks.onClientesChange(localData.clientes);

    // Setup polling to check for changes (useful if multiple tabs are open)
    const pollInterval = setInterval(() => {
      try {
        const currentData = this.getLocalData();
        callbacks.onObrasChange(currentData.obras);
        callbacks.onManutencoesChange(currentData.manutencoes);
        callbacks.onPiscinasChange(currentData.piscinas);
        callbacks.onClientesChange(currentData.clientes);
      } catch (error) {
        console.warn("Erro ao verificar mudan√ßas locais:", error);
      }
    }, 5000); // Check every 5 seconds

    // Return cleanup function
    return () => {
      clearInterval(pollInterval);
      console.log("üõë Listeners locais desconectados");
    };
  }

  /**
   * Configurar listeners universais para todos os tipos de dados
   */
  setupUniversalListeners(callbacks: {
    onObrasChange: (obras: any[]) => void;
    onManutencoesChange: (manutencoes: any[]) => void;
    onPiscinasChange: (piscinas: any[]) => void;
    onClientesChange: (clientes: any[]) => void;
  }): () => void {
    if (!isFirebaseReady() || !db) {
      console.log(
        "üì± Firebase n√£o dispon√≠vel - usando modo local para listeners",
      );

      // Setup localStorage polling as fallback
      return this.setupLocalStorageListeners(callbacks);
    }

    console.log("üì° CONFIGURANDO LISTENERS UNIVERSAIS");
    console.log("üåê TODOS OS UTILIZADORES VER√ÉO OS MESMOS DADOS EM TEMPO REAL");

    const listeners: Unsubscribe[] = [];

    try {
      // Listener para obras universais
      const obrasListener = onSnapshot(
        query(collection(db!, "universal_obras"), orderBy("lastSync", "desc")),
        {
          next: (snapshot) => {
            try {
              const obras = snapshot.docs.map((doc) => ({
                id: doc.id,
                ...doc.data(),
              }));
              console.log(
                `‚öíÔ∏è OBRAS UNIVERSAIS: ${obras.length} vis√≠veis para todos os utilizadores`,
              );
              callbacks.onObrasChange(obras);
            } catch (error) {
              console.error("‚ùå Erro ao processar obras:", error);
              callbacks.onObrasChange([]);
            }
          },
          error: (error) => {
            console.error("‚ùå Erro no listener de obras universais:", error);
            callbacks.onObrasChange([]);
          },
        },
      );
      listeners.push(obrasListener);

      // Listener para manuten√ß√µes universais
      const manutencoesListener = onSnapshot(
        query(
          collection(db!, "universal_manutencoes"),
          orderBy("lastSync", "desc"),
        ),
        {
          next: (snapshot) => {
            try {
              const manutencoes = snapshot.docs.map((doc) => ({
                id: doc.id,
                ...doc.data(),
              }));
              console.log(
                `üîß MANUTEN√á√ïES UNIVERSAIS: ${manutencoes.length} vis√≠veis para todos os utilizadores`,
              );
              callbacks.onManutencoesChange(manutencoes);
            } catch (error) {
              console.error("‚ùå Erro ao processar manuten√ß√µes:", error);
              callbacks.onManutencoesChange([]);
            }
          },
          error: (error) => {
            console.error(
              "‚ùå Erro no listener de manuten√ß√µes universais:",
              error,
            );
            callbacks.onManutencoesChange([]);
          },
        },
      );
      listeners.push(manutencoesListener);

      // Listener para piscinas universais
      const piscinasListener = onSnapshot(
        query(
          collection(db!, "universal_piscinas"),
          orderBy("lastSync", "desc"),
        ),
        {
          next: (snapshot) => {
            try {
              const piscinas = snapshot.docs.map((doc) => ({
                id: doc.id,
                ...doc.data(),
              }));
              console.log(
                `üèä PISCINAS UNIVERSAIS: ${piscinas.length} vis√≠veis para todos os utilizadores`,
              );
              callbacks.onPiscinasChange(piscinas);
            } catch (error) {
              console.error("‚ùå Erro ao processar piscinas:", error);
              callbacks.onPiscinasChange([]);
            }
          },
          error: (error) => {
            console.error("‚ùå Erro no listener de piscinas universais:", error);
            callbacks.onPiscinasChange([]);
          },
        },
      );
      listeners.push(piscinasListener);

      // Listener para clientes universais
      const clientesListener = onSnapshot(
        query(
          collection(db!, "universal_clientes"),
          orderBy("lastSync", "desc"),
        ),
        {
          next: (snapshot) => {
            try {
              const clientes = snapshot.docs.map((doc) => ({
                id: doc.id,
                ...doc.data(),
              }));
              console.log(
                `üë• CLIENTES UNIVERSAIS: ${clientes.length} vis√≠veis para todos os utilizadores`,
              );
              callbacks.onClientesChange(clientes);
            } catch (error) {
              console.error("‚ùå Erro ao processar clientes:", error);
              callbacks.onClientesChange([]);
            }
          },
          error: (error) => {
            console.error("‚ùå Erro no listener de clientes universais:", error);
            callbacks.onClientesChange([]);
          },
        },
      );
      listeners.push(clientesListener);

      this.listeners = listeners;
      console.log(
        "‚úÖ LISTENERS UNIVERSAIS ATIVOS - Sincroniza√ß√£o em tempo real para todos",
      );
    } catch (error) {
      console.error("‚ùå Erro ao configurar listeners universais:", error);
      listeners.forEach((unsubscribe) => {
        try {
          unsubscribe();
        } catch {}
      });
      return () => {};
    }

    return () => {
      console.log("üõë Desconectando listeners universais");
      this.listeners.forEach((unsubscribe) => {
        try {
          unsubscribe();
        } catch (error) {
          console.warn("‚ö†Ô∏è Erro ao desconectar listener:", error);
        }
      });
      this.listeners = [];
    };
  }

  /**
   * Adicionar nova obra universal
   */
  async addObra(obraData: any): Promise<string> {
    try {
      // Wait for Firebase to be ready
      const firebaseReady = await waitForFirebaseInit();
      if (!firebaseReady || !isFirebaseReady() || !db) {
        console.log("üì± Firebase n√£o dispon√≠vel - usando armazenamento local");

        // Fallback to localStorage
        const id = obraData.id || `obra-${Date.now()}-${Math.random()}`;
        const obra = {
          ...obraData,
          id,
          createdAt: obraData.createdAt || new Date().toISOString(),
        };

        const existingWorks = JSON.parse(localStorage.getItem("works") || "[]");
        existingWorks.push(obra);
        localStorage.setItem("works", JSON.stringify(existingWorks));
        localStorage.setItem("lastLocalSync", new Date().toISOString());

        console.log(`‚úÖ OBRA SALVA LOCALMENTE: ${id}`);
        return id;
      }

      const id = obraData.id || `obra-${Date.now()}-${Math.random()}`;
      const obra = {
        ...obraData,
        id,
        universallyShared: true,
        visibleToAllUsers: true,
        createdAt: obraData.createdAt || new Date().toISOString(),
        lastSync: new Date().toISOString(),
      };

      await setDoc(doc(db, "universal_obras", id), obra);
      console.log(
        `‚úÖ OBRA ADICIONADA UNIVERSALMENTE: ${id} - visÔøΩÔøΩvel para todos`,
      );
      return id;
    } catch (error) {
      console.log("üì± Salvando obra localmente:", error.message || error);

      // Fallback to localStorage on any error
      const id = obraData.id || `obra-${Date.now()}-${Math.random()}`;
      const obra = {
        ...obraData,
        id,
        createdAt: obraData.createdAt || new Date().toISOString(),
      };

      const existingWorks = JSON.parse(localStorage.getItem("works") || "[]");
      existingWorks.push(obra);
      localStorage.setItem("works", JSON.stringify(existingWorks));
      localStorage.setItem("lastLocalSync", new Date().toISOString());

      console.log(`‚úÖ OBRA SALVA LOCALMENTE (fallback): ${id}`);
      return id;
    }
  }

  /**
   * Adicionar nova manuten√ß√£o universal
   */
  async addManutencao(manutencaoData: any): Promise<string> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase nÔøΩÔøΩo dispon√≠vel");
    }

    const id = manutencaoData.id || `manutencao-${Date.now()}-${Math.random()}`;
    const manutencao = {
      ...manutencaoData,
      id,
      universallyShared: true,
      visibleToAllUsers: true,
      createdAt: manutencaoData.createdAt || new Date().toISOString(),
      lastSync: new Date().toISOString(),
    };

    await setDoc(doc(db!, "universal_manutencoes", id), manutencao);
    console.log(
      `ÔøΩÔøΩÔøΩ MANUTEN√á√ÉO ADICIONADA UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
    return id;
  }

  /**
   * Adicionar nova piscina universal
   */
  async addPiscina(piscinaData: any): Promise<string> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    const id = piscinaData.id || `piscina-${Date.now()}-${Math.random()}`;
    const piscina = {
      ...piscinaData,
      id,
      universallyShared: true,
      visibleToAllUsers: true,
      createdAt: piscinaData.createdAt || new Date().toISOString(),
      lastSync: new Date().toISOString(),
    };

    await setDoc(doc(db!, "universal_piscinas", id), piscina);
    console.log(
      `‚úÖ PISCINA ADICIONADA UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
    return id;
  }

  /**
   * Adicionar novo cliente universal
   */
  async addCliente(clienteData: any): Promise<string> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    const id = clienteData.id || `cliente-${Date.now()}-${Math.random()}`;
    const cliente = {
      ...clienteData,
      id,
      universallyShared: true,
      visibleToAllUsers: true,
      createdAt: clienteData.createdAt || new Date().toISOString(),
      lastSync: new Date().toISOString(),
    };

    await setDoc(doc(db!, "universal_clientes", id), cliente);
    console.log(
      `‚úÖ CLIENTE ADICIONADO UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
    return id;
  }

  /**
   * Atualizar obra universal
   */
  async updateObra(id: string, obraData: any): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await updateDoc(doc(db!, "universal_obras", id), {
      ...obraData,
      lastSync: new Date().toISOString(),
      universallyShared: true,
      visibleToAllUsers: true,
    });

    console.log(
      `‚úÖ OBRA ATUALIZADA UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
  }

  /**
   * Atualizar manuten√ß√£o universal
   */
  async updateManutencao(id: string, manutencaoData: any): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await updateDoc(doc(db!, "universal_manutencoes", id), {
      ...manutencaoData,
      lastSync: new Date().toISOString(),
      universallyShared: true,
      visibleToAllUsers: true,
    });

    console.log(
      `‚úÖ MANUTEN√á√ÉO ATUALIZADA UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
  }

  /**
   * Atualizar piscina universal
   */
  async updatePiscina(id: string, piscinaData: any): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await updateDoc(doc(db!, "universal_piscinas", id), {
      ...piscinaData,
      lastSync: new Date().toISOString(),
      universallyShared: true,
      visibleToAllUsers: true,
    });

    console.log(
      `‚úÖ PISCINA ATUALIZADA UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
  }

  /**
   * Atualizar cliente universal
   */
  async updateCliente(id: string, clienteData: any): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await updateDoc(doc(db!, "universal_clientes", id), {
      ...clienteData,
      lastSync: new Date().toISOString(),
      universallyShared: true,
      visibleToAllUsers: true,
    });

    console.log(
      `‚úÖ CLIENTE ATUALIZADO UNIVERSALMENTE: ${id} - vis√≠vel para todos`,
    );
  }

  /**
   * Eliminar obra universal
   */
  async deleteObra(id: string): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await deleteDoc(doc(db!, "universal_obras", id));
    console.log(`‚úÖ OBRA ELIMINADA UNIVERSALMENTE: ${id}`);
  }

  /**
   * Eliminar manuten√ß√£o universal
   */
  async deleteManutencao(id: string): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await deleteDoc(doc(db!, "universal_manutencoes", id));
    console.log(`‚úÖ MANUTEN√á√ÉO ELIMINADA UNIVERSALMENTE: ${id}`);
  }

  /**
   * Eliminar piscina universal
   */
  async deletePiscina(id: string): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await deleteDoc(doc(db!, "universal_piscinas", id));
    console.log(`‚úÖ PISCINA ELIMINADA UNIVERSALMENTE: ${id}`);
  }

  /**
   * Eliminar cliente universal
   */
  async deleteCliente(id: string): Promise<void> {
    if (!isFirebaseReady() || !db) {
      throw new Error("Firebase n√£o dispon√≠vel");
    }

    await deleteDoc(doc(db!, "universal_clientes", id));
    console.log(`‚úÖ CLIENTE ELIMINADO UNIVERSALMENTE: ${id}`);
  }

  /**
   * Carregar dados do localStorage
   */
  private getLocalData(): UniversalDataState {
    try {
      const obras = JSON.parse(localStorage.getItem("works") || "[]");
      const manutencoes = JSON.parse(
        localStorage.getItem("maintenance") || "[]",
      );
      const piscinas = JSON.parse(localStorage.getItem("pools") || "[]");
      const clientes = JSON.parse(localStorage.getItem("clients") || "[]");

      return {
        obras,
        manutencoes,
        piscinas,
        clientes,
        totalItems:
          obras.length + manutencoes.length + piscinas.length + clientes.length,
        lastSync:
          localStorage.getItem("lastLocalSync") || new Date().toISOString(),
        isGloballyShared: false, // Local data is not globally shared
      };
    } catch (error) {
      console.warn("Erro ao carregar dados locais:", error);
      return {
        obras: [],
        manutencoes: [],
        piscinas: [],
        clientes: [],
        totalItems: 0,
        lastSync: new Date().toISOString(),
        isGloballyShared: false,
      };
    }
  }

  /**
   * Obter todos os dados universais
   */
  async getAllUniversalData(): Promise<UniversalDataState> {
    if (!isFirebaseReady() || !db) {
      console.log("üì± Carregando dados do armazenamento local");
      return this.getLocalData();
    }

    try {
      const [obrasSnap, manutencoesSnap, piscinasSnap, clientesSnap] =
        await Promise.all([
          getDocs(
            query(
              collection(db!, "universal_obras"),
              orderBy("lastSync", "desc"),
            ),
          ),
          getDocs(
            query(
              collection(db!, "universal_manutencoes"),
              orderBy("lastSync", "desc"),
            ),
          ),
          getDocs(
            query(
              collection(db!, "universal_piscinas"),
              orderBy("lastSync", "desc"),
            ),
          ),
          getDocs(
            query(
              collection(db!, "universal_clientes"),
              orderBy("lastSync", "desc"),
            ),
          ),
        ]);

      const data: UniversalDataState = {
        obras: obrasSnap.docs.map((doc) => ({ id: doc.id, ...doc.data() })),
        manutencoes: manutencoesSnap.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })),
        piscinas: piscinasSnap.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })),
        clientes: clientesSnap.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })),
        totalItems: 0,
        lastSync: new Date().toISOString(),
        isGloballyShared: true,
      };

      data.totalItems =
        data.obras.length +
        data.manutencoes.length +
        data.piscinas.length +
        data.clientes.length;

      console.log("üìä DADOS UNIVERSAIS OBTIDOS:", {
        obras: data.obras.length,
        manutencoes: data.manutencoes.length,
        piscinas: data.piscinas.length,
        clientes: data.clientes.length,
        total: data.totalItems,
      });

      return data;
    } catch (error) {
      console.error("‚ùå Erro ao obter dados universais:", error);
      throw error;
    }
  }

  /**
   * Verificar se o servi√ßo est√° pronto
   */
  isReady(): boolean {
    return this.isInitialized && isFirebaseReady();
  }

  /**
   * Cleanup dos listeners
   */
  cleanup(): void {
    this.listeners.forEach((unsubscribe) => {
      try {
        unsubscribe();
      } catch (error) {
        console.warn("‚ö†Ô∏è Erro ao limpar listener:", error);
      }
    });
    this.listeners = [];
    this.isInitialized = false;
  }
}

// Exportar inst√¢ncia singleton
export const universalDataSync = new UniversalDataSyncService();
export default universalDataSync;
